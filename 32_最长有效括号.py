'''
题目描述:
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"

示例 2：
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"

示例 3：
输入：s = ""
输出：0
 

提示：
0 <= s.length <= 3 * 104
s[i] 为 '(' 或 ')'
'''

'''
解题思路：
方法一：
每次搜索应该都从左括号开始，往右逐渐增加
可参考判断一个字符串是不是有效的括号集
左右指针：
    1. 左指针从左到右遍历 左括号 '('
    2. 右指针从最右往内移动：
        当选定范围内的堆为空时：找到了一个有效串，记录
        当选定范围内的堆不为空时：右指针左移
    3. 当子集判断完成后，结束当前片段
超出时间限制！！！

方法二：
动态规划：
动态规划题目分析的 4 个步骤：
    1.确定状态
        研究最优策略的最后一步
        化为子问题
    2.转移方程
        根据子问题定义得到
    3.初始条件和边界情况
    4.计算顺序


如果一个substr是有效的, f[i][j] = True，则
    1. 要么 f[i+1][j-1] = True, s[i] ='(', s[j] =')'
    2. 要么 f[i][j-2] = True, s[j-1] = '(', s[j] = ')'
    
但是用这么一个二维数组来维护有效字符串效率很低：
    我们只需要看从0到当前位置的有效括号长度就行了，没必要从i到j，因为判断有效括号长度时只需要依赖当前位置前面的字符，不需要依赖其后的，
    所以1维就行了。我理解判断当前状态只需要往前看时就不需要2维。

正确思路：
对于最优的策略，一定有最后一个元素 s[i]
所以，我们先看第 i 个位置，这个位置的元素 s[i]可能有如下两种情况：
s[i] == '('
    这时，s[i]无法和其之前的元素组成有效的括号对，所以，dp[i] = 0

s[i] == ')':
    这时，需要看其前面对元素来判断是否有有效括号对。
    情况1:
    s[i−1]== ′ ( ′：
        即 s[i] 和 s[i−1] 组成一对有效括号，有效括号长度新增长度2，i位置对最长有效括号长度为其之前2个位置的最长括号长度加上当前位置新增的2
        ，我们无需知道i-2位置对字符是否可以组成有效括号对。
    
        那么有： dp[i] = dp[i - 2] + 2
    
    情况2:
    s[i - 1] == ')':
        这种情况下，如果前面有和s[i]组成有效括号对的字符，即形如 ( (....) )，这样的话，就要求s[i - 1]位置必然是有效的括号对，
        否则s[i]无法和前面对字符组成有效括号对。
        这时，我们只需要找到和s[i]配对的位置，并判断其是否是 ( 即可。和其配对的位置为：i - dp[i - 1] - 1。
        如果：s[i - dp[i - 1] - 1] == '(':
        有效括号长度新增长度2，i位置对最长有效括号长度为 i-1位置的最长括号长度加上当前位置新增的2，那么有：
        
        dp[i] = dp[i - 1] + 2
        
        值得注意的是，i - dp[i - 1] - 1和 i 组成了有效括号对，这将是一段独立的有效括号序列，如果之前的子序列是形如 (...)(...) 这种序列，
        那么当前位置的最长有效括号长度还需要加上这一段。所以：
        
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2

子问题：
根据上面的分析，我们得到了如下两个计算公式：
dp[i] = dp[i - 2] + 2
dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2
那么，求dp[i]就变成了求dp[i - 1]、 dp[i - 2]、dp[i - dp[i - 1] - 2]的子问题。
这样状态也明确了：
设dp数组，其中第 i 个元素表示以下标为 i的字符结尾的最长有效子字符串的长度

转移方程：
子问题明确后，转移方程直接由子问题得到：
if s[i] == '(' :
    dp[i] = 0
if s[i] == ')' :
    if s[i - 1] == '(' :
        dp[i] = dp[i - 2] + 2 #要保证i - 2 >= 0

    if s[i - 1] == ')' and s[i - dp[i - 1] - 1] == '(' :
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2 #要保证i - dp[i - 1] - 2 >= 0
        
        
初始条件和边界情况：
初始条件： dp[i] = 0dp[i]=0
边界情况：需要保证计算过程中：i - 2 >= 0i−2>=0 和 i - dp[i - 1] - 2 >= 0i−dp[i−1]−2>=0

计算顺序：
无论第一个字符是什么，都有：dp[0] = 0
然后依次计算：dp[1], dp[2], ..., dp[n - 1]
结果是： max(dp[i])

复杂度计算：
时间复杂度： 遍历了一遍字符串，所以时间复杂度是：O(N)
空间复杂度：需要和字符串长度相同的数组保存每个位置的最长有效括号长度，所以空间复杂度是：O(N)

'''

'''
方法三：
思路和算法

撇开提及的动态规划方法，相信大多数人对于这题的第一直觉是找到每个可能的子串后判断它的有效性，但这样的时间复杂度会达到 O(n^3)，
无法通过所有测试用例。但是通过栈，我们可以在遍历给定字符串的过程中去判断到目前为止扫描的子串的有效性，同时能得到最长有效括号的长度。

具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号')'的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：

对于遇到的每个 ‘(’ ，我们将它的 下标 放入栈中
对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号，之后根据栈情况来判断：
    如果栈为空，说明当前的右括号为没有被匹配的右括号【即栈里没有左括号与其匹配】，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
    如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」
我们从前往后遍历字符串并更新答案即可。

需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，
为了保持统一，我们在一开始的时候往栈中放入一个值为 -1的元素。
'''


'''
方法一：暴力解法

# def longestValidParentheses(s: str) -> int:
#
#     if not s:
#         return 0
#
#     max_len = 0
#
#     n = len(s)
#     start = '('
#
#     # 检查一段字符串是不是有效的括号
#     def checkValid(substr:str) -> bool:
#         stack = []
#         for symbol in substr:
#             if symbol == '(':
#                 stack.append(symbol)
#             elif symbol == ')' and stack:
#                 stack.pop()
#             else:
#                 return False
#
#         # 如果最后 stack为空，则为有效，返回True
#         return not stack
#
#
#     for i in range(n):
#         if n-i <= max_len:
#             break
#         symbol = s[i]
#         if symbol == start:
#             L = i
#             R = n
#             while L<R:
#                 if checkValid(s[L:R]):
#                     max_len = max(max_len, R - L)
#                     break
#                 else:
#                     R -=1
#
#
#     return max_len
'''


'''
方法二: 动态规划
'''
def longestValidParentheses(s: str) -> int:

    if not s:
            return 0

    n = len(s)

    dp = [0]*n
    max_value = 0
    for i in range(1,n):
        if s[i] == ')':
            if s[i-1] == '(':
                # 直接与 s[i] 配对
                dp[i] = 2
                if i-2>=0:
                    dp[i] = dp[i] + dp[i-2]
            elif dp[i-1] >0 :
                # 则要找到一个 "(" 与 s[i]配对且dp[i-1]是有效的
                if (i - dp[i-1] -1)>=0 and s[i - dp[i-1]-1] == '(':
                    dp[i] = dp[i-1] + 2
                    if i - dp[i-1] -2 >=0:
                        dp[i] = dp[i] + dp[i - dp[i-1] -2]

        max_value = max(max_value, dp[i])
    return max_value


if __name__ == '__main__':
    print(longestValidParentheses("(()())"))
    '''
    public:
    int longestValidParentheses(string s) {
        int size = s.length();
        vector<int> dp(size, 0);

        int maxVal = 0;
        for(int i = 1; i < size; i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = 2;
                    if (i - 2 >= 0) {
                        dp[i] = dp[i] + dp[i - 2];
                    }
                } else if (dp[i - 1] > 0) {
                    if ((i - dp[i - 1] - 1) >= 0 && s[i - dp[i - 1] - 1] == '(') {
                        dp[i] = dp[i - 1] + 2;
                        if ((i - dp[i - 1] - 2) >= 0) {
                            dp[i] = dp[i] + dp[i - dp[i - 1] - 2];
                        }
                    }
                }
            }
            maxVal = max(maxVal, dp[i]);
        }
        return maxVal;
    }
};

'''

