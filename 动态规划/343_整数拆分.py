'''
题目描述:
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。
返回你可以获得的最大乘积。

示例 1:
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

说明: 你可以假设 n 不小于 2 且不大于 58。
'''

'''
解题思路:
方法一：
1. 当所有拆分出的数字相等时，乘积最大
2. 最优拆分数字为 3

拆分规则：
最优： 3 。把数字 n 可能拆为多个因子 3 ，余数可能为 0,1,2 三种情况。
次优： 2 。若余数为 2 ；则保留，不再拆为 1+1。
最差： 1 。若余数为 1 ；则应把一份 3 + 1 替换为 2 + 2，因为 2×2>3×1 。


方法二:
动态规划
对于的正整数 n，当 n≥2 时，可以拆分成至少两个正整数的和。令 k 是拆分出的第一个正整数，则剩下的部分是 n-k，
n−k 可以不继续拆分，或者继续拆分成至少两个正整数的和。
由于 每个正整数 对应的最大乘积取决于 比它小的正整数 对应的最大乘积，因此可以使用动态规划求解。

创建数组 dp，其中 dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。
特别地，0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。

当 i>= 2时，假设对正整数 i 拆分出得第一个正整数是 j (1<=j<=i-1)，则有以下两种方案:
    1. 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)
    2. 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。

因此，当 j 固定时，有 dp[i] = max(j×(i−j),j×dp[i−j])。由于 j 的取值范围是 1 到 i−1，
需要遍历所有的 j 得到 dp[i] 的最大值。
最终得到 dp[n] 的值即为将正整数 n 拆分成至少两个正整数的和之后，这些正整数的最大乘积。

'''
class Solution:
    def integerBreak(self, n: int) -> int:
        if n<=3:
            return n-1


        a = n // 3
        b = n % 3
        if b==2:
            return b * 3**a
        if b ==1:
            return 4 * 3**(a-1)
        return 3 ** (a)

    def integerBreak2(self, n: int) -> int:
        # 动态规划
        dp = [0]*(n+1)
        dp[1] = 1
        for i in range(2, n+1):
            for j in range(1, i):
                # 遍历每一个小于 i 的正整数
                dp[i] = max(dp[i], max(j*dp[i-j], j*(i-j)))

        return dp[n]

if __name__ == '__main__':
    dp = []
