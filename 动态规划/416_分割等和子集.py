'''
题目描述:
给你一个 只包含正整数 的 非空 数组 nums 。
请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。


示例 1：
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

示例 2：
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
 

提示：
1 <= nums.length <= 200
1 <= nums[i] <= 100
'''
'''
解题思路:
只要理解本题的每一个元素只有不选择和选择一次两种方式就能联想到0-1背包了。

可以看成一个背包大小为 sum/2 的 0-1 背包问题:
    是否可以从输入数组中挑选出一些正整数，使得这些数的和 等于 整个数组元素的和的一半。
    
本题与 0-1 背包问题有一个很大的不同，即：
    0-1 背包问题选取的 物品的容积总量 不能超过 规定的总量；
    本题选取的数字之和需要 恰好等于 规定的和的一半。
这一点区别，决定了在初始化的时候，所有的值应该初始化为 false。

「0 - 1」 背包问题的思路:
作为「0-1 背包问题」，它的特点是：「每个数只能用一次」。
解决的基本思路是：物品一个一个选，容量也一点一点增加去考虑，这一点是「动态规划」的思想，特别重要。
在实际生活中，我们也是这样做的，一个一个地尝试把候选物品放入「背包」，通过比较得出一个物品要不要拿走。
具体做法是：
    画一个 len 行，target + 1 列的表格。这里 len 是物品的个数，target 是背包的容量。
    len 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始考虑。
    很多时候，我们需要考虑这个容量为 0 的数值。


状态与状态转移方程:
    状态定义：
        dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。

    状态转移方程：
        很多时候，状态转移方程思考的角度是「分类讨论」，对于「0-1 背包问题」而言就是「当前考虑到的数字选与不选」。
            不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；
            选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。
        dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]
        
一般写出状态转移方程以后，就需要考虑初始化条件:
    j - nums[i] 作为数组的下标，一定得保证大于等于 0 ，因此 nums[i] <= j；
    注意到一种非常特殊的情况：j 恰好等于 nums[i]，即单独 nums[j] 这个数恰好等于此时「背包的容积」 j，这也是符合题意的。


考虑空间优化（重要）
说明：这个技巧很常见、很基础，请一定要掌握。

「0-1 背包问题」常规优化：
    「状态数组」从二维降到一维，减少空间复杂度。

在「填表格」的时候，当前行只参考了上一行的值，因此状态数组可以只设置 2 行，
使用「滚动数组」的技巧「填表格」即可；

实际上，在「滚动数组」的基础上还可以优化，在「填表格」的时候，
当前行总是参考了它上面一行 「头顶上」 那个位置和「左上角」某个位置的值。
因此，我们可以只开一个一维数组，从后向前依次填表即可。

「从后向前」 写的过程中，一旦 nums[i] <= j 不满足，可以马上退出当前循环，
因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。
相当于也是一个剪枝，这一点是「从前向后」填表所不具备的。

'''
from typing import List

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sum_all = sum(nums)
        if sum_all%2 != 0:
            return False

        k = sum_all//2
        n = len(nums)
        dp = [[False]* (k+1) for _ in range(n)]

        for i in range(n):
            for j in range(1, k + 1):
                if nums[i] == j:
                    dp[i][j] = True
                else:
                    if i >= 1:
                        dp[i][j] = dp[i - 1][j]
                        if j > nums[i]:
                            dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i]]

        return dp[n-1][k]

    def canPartition2(self, nums: List[int]) -> bool:
        # 优化：压缩为一维数组
        n = len(nums)
        if n == 1:
            return False

        list_sum = sum(nums)
        if list_sum % 2 != 0:
            return False

        target = list_sum//2
        dp = [False]*(target+1)
        dp[0] = True

        if nums[0] <= target:
            # 因为当 target 从小到大遍历时，
            # 一定会碰到等于nums[0]的数字，此时dp一定为true，因为一定能找到一个数等于target
            dp[nums[0]] = True

        '''
        j 的每次循环其实是查看当前nums[i]能不能和之前的数字凑成 和为 j
        而配合上外圈的 i 的循环，就可以依次从数组的左边到右边累计数字看能不能凑出 和 为 target 的情况
        
        倒序：
        每次查找其实是搜索左边的值，如果正序先更新了，那么轮到target的时候，相当于在二维数组中左边同一行的值就会影响到当前行
        而且我们在二维数组中注意到，当出现一个 true后，数组同一列，其下面的所有行都为true，
        在倒序的时候，就可以先把 diff 对应列在本行的值先不考虑，而是考虑上一行在这一列的值，最后在用当前行去更新，
        因为一旦上一行在这一列是true，那当前行这一列必然是true,如果过上一行是false,而这一行是true，则只能记录作为下一行的参考，
        不能作为本行更新 j 的参考。
        '''
        for i in range(1, n):
            # 只有 target >= nums[i] 时，才会进入
            for j in range(target, nums[i]-1, -1):
                if dp[target]:
                    return True
                # 实际上是用的 i - 1 层 dp[j] 和 dp[j - nums[i]] 得出的
                dp[j] |= dp[j - nums[i]]

        return dp[target]






if __name__ == '__main__':
    nums = [2,2,1,1]
    sol = Solution()
    print(sol.canPartition2(nums))