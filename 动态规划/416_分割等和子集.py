'''
题目描述:
给你一个 只包含正整数 的 非空 数组 nums 。
请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。


示例 1：
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

示例 2：
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
 

提示：
1 <= nums.length <= 200
1 <= nums[i] <= 100
'''
'''
解题思路:
只要理解本题的每一个元素只有不选择和选择一次两种方式就能联想到0-1背包了。

可以看成一个背包大小为 sum/2 的 0-1 背包问题:
    是否可以从输入数组中挑选出一些正整数，使得这些数的和 等于 整个数组元素的和的一半。
    
本题与 0-1 背包问题有一个很大的不同，即：
    0-1 背包问题选取的 物品的容积总量 不能超过 规定的总量；
    本题选取的数字之和需要 恰好等于 规定的和的一半。
这一点区别，决定了在初始化的时候，所有的值应该初始化为 false。

「0 - 1」 背包问题的思路:
作为「0-1 背包问题」，它的特点是：「每个数只能用一次」。
解决的基本思路是：物品一个一个选，容量也一点一点增加去考虑，这一点是「动态规划」的思想，特别重要。
在实际生活中，我们也是这样做的，一个一个地尝试把候选物品放入「背包」，通过比较得出一个物品要不要拿走。
具体做法是：
    画一个 len 行，target + 1 列的表格。这里 len 是物品的个数，target 是背包的容量。
    len 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始考虑。
    很多时候，我们需要考虑这个容量为 0 的数值。


状态与状态转移方程:
    状态定义：
        dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。

    状态转移方程：
        很多时候，状态转移方程思考的角度是「分类讨论」，对于「0-1 背包问题」而言就是「当前考虑到的数字选与不选」。
            不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；
            选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。
        dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]
        
一般写出状态转移方程以后，就需要考虑初始化条件:
    j - nums[i] 作为数组的下标，一定得保证大于等于 0 ，因此 nums[i] <= j；
    注意到一种非常特殊的情况：j 恰好等于 nums[i]，即单独 nums[j] 这个数恰好等于此时「背包的容积」 j，这也是符合题意的。


考虑空间优化（重要）
说明：这个技巧很常见、很基础，请一定要掌握。

「0-1 背包问题」常规优化：
    「状态数组」从二维降到一维，减少空间复杂度。

在「填表格」的时候，当前行只参考了上一行的值，因此状态数组可以只设置 2 行，
使用「滚动数组」的技巧「填表格」即可；

实际上，在「滚动数组」的基础上还可以优化，在「填表格」的时候，
当前行总是参考了它上面一行 「头顶上」 那个位置和「左上角」某个位置的值。
因此，我们可以只开一个一维数组，从后向前依次填表即可。

「从后向前」 写的过程中，一旦 nums[i] <= j 不满足，可以马上退出当前循环，
因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。
相当于也是一个剪枝，这一点是「从前向后」填表所不具备的。

'''
from typing import List

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sum_all = sum(nums)
        if sum_all%2 != 0:
            return False

        k = sum_all//2
        n = len(nums)
        dp = [[False]* (k+1) for _ in range(n)]

        for i in range(n):
            for j in range(1, k + 1):
                if nums[i] == j:
                    dp[i][j] = True
                else:
                    if i >= 1:
                        dp[i][j] = dp[i - 1][j]
                        if j > nums[i]:
                            dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i]]

        return dp[n-1][k]

if __name__ == '__main__':
    nums = [2,2,1,1]
    sol = Solution()
    sol.canPartition(nums)